// from: https://github.com/rodw/tiny-node.js-webserver/blob/master/tnws.coffee
// Generated by CoffeeScript 1.6.3
(function() {
  var MIME_TYPES, args, expect_value, fs, get_mime, http, options, path, request_handler, respond, serve_file, server, val;

  path = require('path');

  http = require('http');

  fs = require('fs');

  MIME_TYPES = {
    'css': 'text/css',
    'gif': 'image/gif',
    'htm': 'text/html',
    'html': 'text/html',
    'ico': 'image/x-icon',
    'jpeg': 'image/jpeg',
    'jpg': 'image/jpeg',
    'js': 'text/javascript',
    'json': 'application/json',
    'png': 'image/png',
    'txt': 'text/text'
  };

  get_mime = function(filename) {
    var ext, type;
    for (ext in MIME_TYPES) {
      type = MIME_TYPES[ext];
      if (filename.indexOf(ext, filename.length - ext.length) !== -1) {
        return type;
      }
    }
    return null;
  };

  options = {};

  expect_value = function(array, prefix) {
    if (array.length === 0) {
      console.warn("WARNING: Expected a value following \"" + prefix + "\"");
      return null;
    } else {
      return array.shift();
    }
  };

  args = process.argv;

  args.shift();

  args.shift();

  while (args.length > 0) {
    switch (val = args.shift()) {
      case '--port':
      case '-p':
        options.port = expect_value(args, val);
        break;
      case '--host':
      case '-h':
        options.host = expect_value(args, val);
        break;
      case '--index':
      case '-i':
        options.index = expect_value(args, val);
        break;
      case '--docroot':
      case '-d':
        options.docroot = expect_value(args, val);
        break;
      case '--mime-type':
      case '-m':
        MIME_TYPES[expect_value(args, val)] = expect_value(args, val);
        break;
      case '--quiet':
      case '-q':
        options.quiet = true;
        break;
      case '--silent':
      case '-s':
        options.silent = true;
        break;
      default:
        console.warn("WARNING: The option \"" + val + "\" is not recognized.");
    }
  }

  if (options.host == null) {
    options.host = 'localhost';
  }

  if (options.port == null) {
    options.port = 8080;
  }

  if (options.index == null) {
    options.index = 'index.html';
  }

  if (options.docroot == null) {
    options.docroot = '.';
  }

  if (options.quiet == null) {
    options.quiet = false;
  }

  if (options.silent == null) {
    options.silent = false;
  }

  if (options.silent) {
    options.quiet = true;
  }

  respond = function(request, response, status, content, content_type) {
    if (status == null) {
      status = 200;
    }
    if (content == null) {
      content = null;
    }
    if (content_type == null) {
      content_type = null;
    }
    options.quiet || console.log("" + status + "\t" + request.method + "\t" + request.url);
    response.writeHead(status, {
      "Content-Type": content_type
    });
    if (content != null) {
      response.write(content);
    }
    return response.end();
  };

  serve_file = function(request, response, requestpath) {
    return fs.readFile(requestpath, function(error, content) {
      if (error != null) {
        console.error("ERROR: Encountered error while processing " + request.method + " of \"" + request.url + "\".", error);
        return respond(request, response, 500);
      } else {
        return respond(request, response, 200, content, get_mime(requestpath));
      }
    });
  };

  request_handler = function(request, response) {
    var requestpath;
    if (request.url.match(/((\.|%2E|%2e)(\.|%2E|%2e))|(~|%7E|%7e)/) != null) {
      options.quiet || console.warn("WARNING: " + request.method + " of \"" + request.url + "\" rejected as insecure.");
      return respond(request, response, 403);
    } else {
      requestpath = path.normalize(path.join(options.docroot, request.url));
      return path.exists(requestpath, function(file_exists) {
        if (file_exists) {
          return fs.stat(requestpath, function(err, stat) {
            if (err != null) {
              console.error("ERROR: Encountered error calling fs.stat on \"" + requestpath + "\" while processing " + request.method + " of \"" + request.url + "\".", err);
              return respond(request, response, 500);
            } else {
              if ((stat != null) && stat.isDirectory()) {
                if (requestpath.substr(-1) !== '/') {
                  requestpath += "/";
                }
                requestpath += options.index;
                return path.exists(requestpath, function(file_exists) {
                  if (file_exists) {
                    return serve_file(request, response, requestpath);
                  } else {
                    return respond(request, response, 404);
                  }
                });
              } else {
                return serve_file(request, response, requestpath);
              }
            }
          });
        } else {
          return respond(request, response, 404);
        }
      });
    }
  };

  server = http.createServer(request_handler);

  server.listen(options.port, options.host, function() {
    return options.silent || console.log("Server listening at http://" + options.host + ":" + options.port + "/");
  });

}).call(this);